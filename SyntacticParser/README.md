#### 编译原理实验：


##### 基于异常的错误处理

- 递归下降算法多处会匹配，如果匹配失败，就返回
- 如果使用`if`进行判断，可读性会很差
- 可以使用宏来包装`if`，但是这样容易出错，且不方便调试
- 基于异常的错误处理：在发现错误后，抛出异常，起到了返回的效果
- 将一个递归下降的产生式抽象为一个类：`RD_Case`
	- 调用这个类的`Run()`方法，就完成了一次递归下降的过程
	- `Run()`主要是异常捕获，该方法会调用`_RunException()`方法，`_RunException()`方法是生成式的主要过程。
	- 如果发生必要错误，就抛出异常
	- 由于这个类引用了`_reader`对象，为了在发生错误以后不会影响`_reader`，应该重置`_reader->Index`指针
- `_Init()`函数用于初始化，检测是否存在第一个`token`
- `_check*()`函数都会抛出异常，而`_match*()`函数不会。
- 以堆栈的形式生成错误对象
- 与reader的关系：先构建错误对象，再reader的index回退

##### 设计`reader`类

- 这个类专门用来读取词法分析的结果`token`。
- 这个类有一个重要的属性：`index`，指向**正要**读取的`token`。
- 开始时，`index`的值是`0`
- 如果读取完毕了，所有`token`都处理了，那么`index = count`。

##### 一些设计思路

- 将读写相关的过程单独分离出来

##### 错误信息

- 产生式会给出什么级别的错误信息
- Run()里面会得到什么级别的错误信息
- 错误拼装流程是怎样的

##### 特殊子节点的行号

- 各种sequence节点的行号是0
